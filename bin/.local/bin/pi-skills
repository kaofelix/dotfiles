#!/usr/bin/env python3
"""
PI Skills Manager - Interactive skill selection using gum
Manage which skills are loaded by copying/deleting from the skills folder
"""

import os
import re
import shlex
import shutil
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import TypedDict

# Configuration
# Target: where skills are loaded from in home directory
SKILLS_TARGET = Path.home() / ".pi/agent/skills"

# Source: where original skills are kept (in dotfiles)
# Get dotfiles root relative to script location
SCRIPT_DIR = Path(__file__).resolve().parent
DOTFILES_DIR = SCRIPT_DIR.parent.parent.parent
SKILLS_SOURCE = DOTFILES_DIR / "skills"

# Colors
GREEN = "\033[0;32m"
YELLOW = "\033[1;33m"
BLUE = "\033[0;34m"
RED = "\033[0;31m"
NC = "\033[0m"


@dataclass
class Skill:
    name: str
    description: str
    src_path: Path
    installed_path: Path | None

    def is_installed(self) -> bool:
        return self.installed_path is not None


def print_usage():
    print("""
PI Skills Manager - Manage which skills are loaded by the PI agent
Skills are copied/deleted directly in ~/.pi/agent/skills/

Usage: pi-skills [COMMAND]

COMMANDS:
    list                    List all skills with their status
    select                  Interactive menu to enable/disable skills
    enable <skill>          Enable a skill (copy from source)
    disable <skill>         Disable a skill (delete from target)
    help, -h, --help        Show this help message

EXAMPLES:
    pi-skills list                          Show all skills
    pi-skills select                        Toggle skills in interactive menu
    pi-skills enable ast-grep               Copy ast-grep to skills folder
    pi-skills disable browser-tools         Delete browser-tools from skills folder
""")


class SkillData(TypedDict):
    name: str
    description: str
    src_path: Path


def parse_skill_metadata(skill_file: Path) -> SkillData:
    data: SkillData = {
        "name": skill_file.parent.name,
        "src_path": skill_file.parent,
        "description": "No description",
    }

    content = skill_file.read_text()
    frontmatter_match = re.match(r"^---\n(.*?)\n---", content, re.DOTALL)

    if frontmatter_match:
        frontmatter = frontmatter_match.group(1)
        for line in frontmatter.split("\n"):
            if line.startswith("name:"):
                data["name"] = line.split(":", 1)[1].strip().strip("\"'")
            elif line.startswith("description:"):
                data["description"] = line.split(":", 1)[1].strip().strip("\"'")

    return data


def get_skills() -> list[Skill]:
    source_skills = [
        parse_skill_metadata(skill_file)
        for skill_file in SKILLS_SOURCE.rglob("SKILL.md")
    ]

    installed_skills = {
        skill_file.parent.name: {"installed_path": skill_file.parent}
        for skill_file in SKILLS_TARGET.rglob("SKILL.md")
    }

    skills: list[Skill] = []
    for data in source_skills:
        installed_data: dict[str, Path] = installed_skills.get(data["name"], {})
        skill = Skill(installed_path=installed_data.get("installed_path"), **data)
        skills.append(skill)

    return sorted(skills, key=lambda s: s.name)


def list_skills():
    """List all skills with their status"""
    skills = get_skills()

    print(f"{BLUE}Available Skills:{NC}")
    print()

    for skill in skills:
        status_icon = f"{GREEN}✓{NC}" if skill.is_installed() else f"{YELLOW}✗{NC}"
        print(f"  {status_icon}  {BLUE}{skill.name}{NC}")
        print(f"        {skill.description}")
        print()


def gum_choose(skills: list[Skill]) -> list[str] | None:
    """
    Use gum choose to interactively select skills

    Args:
        skills: List of Skill objects

    Returns:
        List of selected skill names, or None if cancelled
    """
    # Get skill names
    choices = [skill.name for skill in skills]

    # Get currently installed skills to pre-select
    selected_skills = [skill.name for skill in skills if skill.is_installed()]

    # Build command parts
    cmd_parts = ["gum", "choose", "--height", "20"]

    # Add header
    cmd_parts.append("--header")
    cmd_parts.append(
        "Select skills to enable (space=toggle, enter=confirm, ESC=cancel)"
    )

    cmd_parts.extend(["--cursor-prefix", "> "])
    cmd_parts.extend(["--selected-prefix", "✓ "])
    cmd_parts.extend(["--unselected-prefix", "  "])
    cmd_parts.append("--no-limit")

    # Add pre-selected items as comma-separated list
    if selected_skills:
        cmd_parts.append(f"--selected={','.join(selected_skills)}")

    # Add all choices as arguments
    cmd_parts.extend(choices)

    # Escape and join
    cmd = " ".join(shlex.quote(arg) for arg in cmd_parts)

    # Use os.popen to run gum and capture output
    # This allows gum to access the TTY for interactive input
    output = os.popen(cmd).read()

    if not output:
        return None

    # Parse selected skills (one per line)
    selected = [line.strip() for line in output.strip().split("\n") if line.strip()]
    return selected


def enable_skill(skill_name: str) -> int:
    """
    Enable a skill by copying from source to target

    Args:
        skill_name: Name of the skill to enable

    Returns:
        Exit code (0 for success, 1 for error)
    """
    skills = get_skills()
    skill = next((s for s in skills if s.name == skill_name), None)

    if not skill:
        print(f"{RED}Error: Unknown skill '{skill_name}'{NC}", file=sys.stderr)
        available = ", ".join(s.name for s in skills)
        print(f"{YELLOW}Available skills: {available}{NC}")
        return 1

    target = SKILLS_TARGET / skill_name

    # Create target directory if needed
    SKILLS_TARGET.mkdir(parents=True, exist_ok=True)

    # Copy the skill directory
    if target.exists():
        print(f"{YELLOW}Skill '{skill_name}' already present, re-copying...{NC}")
        shutil.rmtree(target)

    shutil.copytree(skill.src_path, target)
    print(f"{GREEN}✓ Enabled: {skill_name}{NC}")
    return 0


def disable_skill(skill_name: str) -> int:
    """
    Disable a skill by deleting from target

    Args:
        skill_name: Name of the skill to disable

    Returns:
        Exit code (0 for success, 1 for error)
    """
    skills = get_skills()
    skill = next((s for s in skills if s.name == skill_name), None)

    if not skill or not skill.is_installed():
        print(f"{YELLOW}Skill '{skill_name}' not currently enabled{NC}")
        return 0

    shutil.rmtree(skill.installed_path)
    print(f"{GREEN}✓ Disabled: {skill_name}{NC}")
    return 0


def select_skills() -> int:
    """
    Interactive skill selection menu

    Returns:
        Exit code (0 for success, 1 for error)
    """
    skills = get_skills()

    if not skills:
        print(f"{RED}No skills found{NC}", file=sys.stderr)
        return 1

    selected = gum_choose(skills)

    if selected is None:
        print(f"{YELLOW}Cancelled{NC}")
        return 0

    # Sync: delete skills not selected, copy selected skills
    enabled_count = 0
    disabled_count = 0

    # First, disable any skills not in selected
    selected_set = set(selected)
    for skill in skills:
        if skill.is_installed() and skill.name not in selected_set:
            shutil.rmtree(skill.installed_path)
            disabled_count += 1

    # Then, enable selected skills that aren't present
    for skill in skills:
        if skill.name in selected_set and not skill.is_installed():
            shutil.copytree(skill.src_path, SKILLS_TARGET / skill.name)
            enabled_count += 1

    print(f"{GREEN}✓ Updated: {enabled_count} enabled, {disabled_count} disabled{NC}")
    return 0


def main():
    if len(sys.argv) < 2:
        print_usage()
        sys.exit(1)

    command = sys.argv[1]

    if command in ("help", "-h", "--help"):
        print_usage()
        sys.exit(0)
    elif command == "list":
        list_skills()
    elif command == "select":
        sys.exit(select_skills())
    elif command == "enable":
        if len(sys.argv) < 3:
            print(f"{RED}Error: missing skill name{NC}", file=sys.stderr)
            print_usage()
            sys.exit(1)
        sys.exit(enable_skill(sys.argv[2]))
    elif command == "disable":
        if len(sys.argv) < 3:
            print(f"{RED}Error: missing skill name{NC}", file=sys.stderr)
            print_usage()
            sys.exit(1)
        sys.exit(disable_skill(sys.argv[2]))
    else:
        print(f"{RED}Error: unknown command '{command}'{NC}", file=sys.stderr)
        print_usage()
        sys.exit(1)


if __name__ == "__main__":
    main()
