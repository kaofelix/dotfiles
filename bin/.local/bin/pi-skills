#!/usr/bin/env python3
"""
PI Skills Manager - Interactive skill selection using gum
Manage which skills are loaded by symlinking from the skills folder
"""

import os
import re
import shlex
import shutil
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import TypedDict

# Configuration
# Target: where skills are loaded from in home directory
SKILLS_TARGET = Path.home() / ".pi/agent/skills"

# Source: where original skills are kept (in dotfiles)
# Get dotfiles root relative to script location
SCRIPT_DIR = Path(__file__).resolve().parent
DOTFILES_DIR = SCRIPT_DIR.parent.parent.parent
SKILLS_SOURCE = DOTFILES_DIR / "skills"

# Colors
GREEN = "\033[0;32m"
YELLOW = "\033[1;33m"
BLUE = "\033[0;34m"
RED = "\033[0;31m"
NC = "\033[0m"


@dataclass
class Skill:
    name: str
    description: str
    src_path: Path
    installed_path: Path | None

    def is_installed(self) -> bool:
        return self.installed_path is not None


def print_usage():
    print("""
PI Skills Manager - Manage which skills are loaded by the PI agent
Skills are symlinked/deleted directly in ~/.pi/agent/skills/

Usage: pi-skills [COMMAND]

COMMANDS:
    list                    List all skills with their status
    select                  Interactive menu to enable/disable skills
    enable <skill>          Enable a skill (symlink from source)
    disable <skill>         Disable a skill (remove symlink from target)
    help, -h, --help        Show this help message

EXAMPLES:
    pi-skills list                          Show all skills
    pi-skills select                        Toggle skills in interactive menu
    pi-skills enable ast-grep               Symlink ast-grep to skills folder
    pi-skills disable browser-tools         Remove browser-tools symlink from skills folder
""")


class SkillData(TypedDict):
    name: str
    description: str
    src_path: Path


def parse_skill_metadata(skill_file: Path) -> SkillData:
    data: SkillData = {
        "name": skill_file.parent.name,
        "src_path": skill_file.parent,
        "description": "No description",
    }

    content = skill_file.read_text()
    frontmatter_match = re.match(r"^---\n(.*?)\n---", content, re.DOTALL)

    if frontmatter_match:
        frontmatter = frontmatter_match.group(1)
        for line in frontmatter.split("\n"):
            if line.startswith("name:"):
                data["name"] = line.split(":", 1)[1].strip().strip("\"'")
            elif line.startswith("description:"):
                data["description"] = line.split(":", 1)[1].strip().strip("\"'")

    return data


def get_skills() -> list[Skill]:
    source_skills = [
        parse_skill_metadata(skill_file)
        for skill_file in SKILLS_SOURCE.rglob("SKILL.md")
    ]

    # Use os.walk with followlinks=True to find skills through symlinks
    installed_skills = {}
    for root, dirs, files in os.walk(SKILLS_TARGET, followlinks=True):
        for file in files:
            if file == "SKILL.md":
                skill_path = Path(root)
                installed_skills[skill_path.name] = {"installed_path": skill_path}

    skills: list[Skill] = []
    for data in source_skills:
        installed_data: dict[str, Path] = installed_skills.get(data["name"], {})
        skill = Skill(installed_path=installed_data.get("installed_path"), **data)
        skills.append(skill)

    return sorted(skills, key=lambda s: s.name)


def list_skills():
    """List all skills with their status"""
    skills = get_skills()

    print(f"{BLUE}Available Skills:{NC}")
    print()

    for skill in skills:
        status_icon = f"{GREEN}✓{NC}" if skill.is_installed() else f"{YELLOW}✗{NC}"
        print(f"  {status_icon}  {BLUE}{skill.name}{NC}")
        print(f"        {skill.description}")
        print()


def gum_choose(skills: list[Skill]) -> list[str] | None:
    """
    Use gum choose to interactively select skills

    Args:
        skills: List of Skill objects

    Returns:
        List of selected skill names, or None if cancelled
    """
    # Get skill names
    choices = [skill.name for skill in skills]

    # Get currently installed skills to pre-select
    selected_skills = [skill.name for skill in skills if skill.is_installed()]

    # Build command parts
    cmd_parts = ["gum", "choose", "--height", "20"]

    # Add header
    cmd_parts.append("--header")
    cmd_parts.append(
        "Select skills to enable (space=toggle, enter=confirm, ESC=cancel)"
    )

    cmd_parts.extend(["--cursor-prefix", "> "])
    cmd_parts.extend(["--selected-prefix", "✓ "])
    cmd_parts.extend(["--unselected-prefix", "  "])
    cmd_parts.append("--no-limit")

    # Add pre-selected items as comma-separated list
    if selected_skills:
        cmd_parts.append(f"--selected={','.join(selected_skills)}")

    # Add all choices as arguments
    cmd_parts.extend(choices)

    # Escape and join
    cmd = " ".join(shlex.quote(arg) for arg in cmd_parts)

    # Use os.popen to run gum and capture output
    # This allows gum to access the TTY for interactive input
    output = os.popen(cmd).read()

    if not output:
        return None

    # Parse selected skills (one per line)
    selected = [line.strip() for line in output.strip().split("\n") if line.strip()]
    return selected


def enable_skill(skill_name: str) -> int:
    """
    Enable a skill by creating a symlink from source to target

    Args:
        skill_name: Name of the skill to enable

    Returns:
        Exit code (0 for success, 1 for error)
    """
    skills = get_skills()
    skill = next((s for s in skills if s.name == skill_name), None)

    if not skill:
        print(f"{RED}Error: Unknown skill '{skill_name}'{NC}", file=sys.stderr)
        available = ", ".join(s.name for s in skills)
        print(f"{YELLOW}Available skills: {available}{NC}")
        return 1

    target = SKILLS_TARGET / skill_name

    # Create target directory if needed
    SKILLS_TARGET.mkdir(parents=True, exist_ok=True)

    # Remove existing target if present (symlink or directory)
    if target.exists() or target.is_symlink():
        print(f"{YELLOW}Skill '{skill_name}' already present, re-linking...{NC}")
        if target.is_dir() and not target.is_symlink():
            shutil.rmtree(target)
        else:
            target.unlink()

    # Create symlink
    target.symlink_to(skill.src_path)
    print(f"{GREEN}✓ Enabled: {skill_name}{NC}")
    return 0


def disable_skill(skill_name: str) -> int:
    """
    Disable a skill by removing symlink from target

    Args:
        skill_name: Name of the skill to disable

    Returns:
        Exit code (0 for success, 1 for error)
    """
    skills = get_skills()
    skill = next((s for s in skills if s.name == skill_name), None)

    if not skill or not skill.is_installed():
        print(f"{YELLOW}Skill '{skill_name}' not currently enabled{NC}")
        return 0

    # Remove symlink or directory
    if skill.installed_path.is_dir() and not skill.installed_path.is_symlink():
        shutil.rmtree(skill.installed_path)
    else:
        skill.installed_path.unlink()
    print(f"{GREEN}✓ Disabled: {skill_name}{NC}")
    return 0


def select_skills() -> int:
    """
    Interactive skill selection menu

    Returns:
        Exit code (0 for success, 1 for error)
    """
    skills = get_skills()

    if not skills:
        print(f"{RED}No skills found{NC}", file=sys.stderr)
        return 1

    selected = gum_choose(skills)

    if selected is None:
        print(f"{YELLOW}Cancelled{NC}")
        return 0

    # Sync: remove skills not selected, symlink selected skills
    enabled_count = 0
    disabled_count = 0

    # First, disable any skills not in selected
    selected_set = set(selected)
    for skill in skills:
        if skill.is_installed() and skill.name not in selected_set:
            # Remove symlink or directory
            if skill.installed_path.is_dir() and not skill.installed_path.is_symlink():
                shutil.rmtree(skill.installed_path)
            else:
                skill.installed_path.unlink()
            disabled_count += 1

    # Then, enable selected skills that aren't present
    for skill in skills:
        if skill.name in selected_set and not skill.is_installed():
            (SKILLS_TARGET / skill.name).symlink_to(skill.src_path)
            enabled_count += 1

    print(f"{GREEN}✓ Updated: {enabled_count} enabled, {disabled_count} disabled{NC}")
    return 0


def main():
    if len(sys.argv) < 2:
        print_usage()
        sys.exit(1)

    command = sys.argv[1]

    if command in ("help", "-h", "--help"):
        print_usage()
        sys.exit(0)
    elif command == "list":
        list_skills()
    elif command == "select":
        sys.exit(select_skills())
    elif command == "enable":
        if len(sys.argv) < 3:
            print(f"{RED}Error: missing skill name{NC}", file=sys.stderr)
            print_usage()
            sys.exit(1)
        sys.exit(enable_skill(sys.argv[2]))
    elif command == "disable":
        if len(sys.argv) < 3:
            print(f"{RED}Error: missing skill name{NC}", file=sys.stderr)
            print_usage()
            sys.exit(1)
        sys.exit(disable_skill(sys.argv[2]))
    else:
        print(f"{RED}Error: unknown command '{command}'{NC}", file=sys.stderr)
        print_usage()
        sys.exit(1)


if __name__ == "__main__":
    main()
